面试：
1. 读题（出声）
2. 标注input, 备注parameter/variable.
3. 点明题目标出的解范围，讨论边界值。i.e. exactly one solution in two sum.
    - assumption: range of input and output, more than one solution, extreme situation, communicate with interviewer.
4. output: 考虑output的空值情况，声明output特殊情况。
5. 想好用什么方式去做. i.e. brute force, big-o, O(n^2) for twosum.
6. 知道怎么做优化： 告诉面试官为何这么做， 时间复杂度是多少，[i.e. binary search, hashmap(twosum)-O(1)]
7. 不知道如何优化： 说明知道暴力枚举解法， 不知道optimal solution right now, do you want me start brute forcing or do we keep disussing
  optimizing.
    - may get hints
    - communicate is important.
8. 开始写答案时,多加comment：
            - class Solution {
            public:
                //hints: i enter two inputs here
                vector<int> twoSum(vector<int>& nums, int target) {

                //innitialize variable.
                    vector<int> sumIndexs;

                //here using double loop to find target index
                    for (int i=0; i<nums.size(); i++){
                        for (int j=i+1; j<nums.size(); j++){
                            //if (j!=i){
                                int elementsSum=nums[i]+nums[j];

                //indicate if the correct answer is reached, return sum index if yes.
                                if (elementsSum == target){
                                    sumIndexs.push_back(i);
                                    sumIndexs.push_back(j);

                                    // return correct answer
                                    return sumIndexs;  
                                }
                            //}
                        }
                    }

                //if null: return null.
                    if (sumIndexs.empty()){
                        return {};
                    }
                    else{
                        return sumIndexs;
                    }
                }
            };
    
    
9. 注意边写边优化的过程也要保持交流。
10. 判断边界值、空值情况，加入testing condition
11. follows up: 面试完后，提出对优化解法的理解。
12. binary search. double pointer, sliding window
    -labuladong 框架记忆.
    
    react-redux 框架  albinotonnina- component
    -提供状态容器， lets application run in any environment ( server side/ customer side )
    react hooks 
    
    第 1 - 2 分钟完成自我介绍、热身。

    第 3 - 10 分钟完成读题，完成 Clarification。

    第 10 - 15 分钟交代解题思路，Dry-Run 一个样例，并分析复杂度。

    第 15 - 25/30 分钟完成 Coding，并跑样例。

    第 25/30 - 40 分钟完成 Follow Up。

    第 40 - 45 分钟完成 Q&A。
    
    
    
    webhack babel 
    - advanced react
    - library management tool
    
react 优点： 
1.代码复用， 组件化开发， 高效轻量
2.关注应用中数据流， 适用于常见开发
3. NEXT.JS -- reactjs按次加载， nextjs按需加载， nextjs基于reactjs建立， 对规模大的数据，nextjs可以快速加载需要看到的部分。
4. 业界流行： NEXTJS + graphql（前段sql数据化包）
mysql， sql database, 高度结构化数据适用， 应用场景： 银行系统（oracle）， 在线商店， 因为数据需要精确标注，定义明确。ie用户账号地址需要结构化查询，且用户数据增长规模可预期， 
mango db, non-sql， 门槛低， 科技公司里广泛使用， 应用场景：主要AI， 社交网络，管理与网络分析系统（适合模糊处理， 全文搜索，machine learning，数据海量增长速度难以预期）。非关系型数据库， 用于超大型规模数据的存储， ie 谷歌， amz， 每天万亿比特数据量， 多且杂， 不需要固定模式、操作， nosql可以横向扩展适合这种多且杂的数据。

5.许多大型互联网项目都会用 sql database + non-sql 的组合方式， 
6. jsx, 
state, 
props,
